<!doctype html>
<html lang="en-us">
    <a id="topOfPage"></a>
    <head>
        

<meta property="og:title" content="Programmateur" />
<meta property="og:description" content="Kit d’automatisation - Planificateur" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://microsoft.github.io/powercat-automation-kit/fr/features/scheduler/" /><meta property="article:section" content="features" />





<meta name="description" content="Kit d’automatisation pour Power Platform site de démarrage. Définissez et mesurez le retour sur investissement de Power Automate Desktop, établissez des liens vers du contenu d’apprentissage et des témoignages clients." />
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="x-ua-compatible" content="ie=edge">

<meta name="og:image" content="https://microsoft.github.io/powercat-automation-kit/images/logos/automation-kit.png" />
<meta name="og:image:alt" content="Automation Kit Logo" />

        <title>Automation Kit for Power Platform</title>
        
<link rel="icon" type="image/png" href="https://microsoft.github.io/powercat-automation-kit/images/favicon.png" />
<link rel="stylesheet" type="text/css" href="https://microsoft.github.io/powercat-automation-kit/css/style.min.900ac3346e02b249eca52c9ae838525e38bee9dc718fb9fd6cc0fbcfa923b149.css" integrity="sha256-kArDNG4CsknspSya6DhSXji&#43;6dxxj7n9bMD7z6kjsUk=">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/vs.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<link rel="stylesheet" type="text/css" href="https://microsoft.github.io/powercat-automation-kit/css/icons.css">
<link href="https://microsoft.github.io/powercat-automation-kit/css/survey-jquery/modern.min.css" type="text/css" rel="stylesheet">
<script type="module" src="https://unpkg.com/@fluentui/web-components"></script>

    </head>
    <body>
    

    
<nav class="navbar navbar-expand-lg navbar-dark bg-gray">
    <div class="container d-flex justify-content-between">
        <a class="navbar-item" href="https://microsoft.github.io/powercat-automation-kit/fr/">
          <img src="https://microsoft.github.io/powercat-automation-kit/images/logos/automation-kit.svg" alt="" width="112" height="56">
        </a>
        <span class="my-1 title text-black">Kit d’automatisation pour Power Platform</span>
    </div>
</nav>
<article>
  <a id="topofpage"></a>
  <div class="container">
    <div class="columns">
      <div class="column is-centered-tablet-portrait">
        <h1 class="title section-title">Programmateur</h1>
        <h5 class="subtitle is-5 is-muted"></h5>
        <div class="divider"></div>
      </div>
    </div>

    <div class="content">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#flux-de-nuages">Flux de nuages</a></li>
    <li><a href="#affichages-du-calendrier">Affichages du calendrier</a></li>
    <li><a href="#vues-jour-semaine-mois">Vues jour, semaine, mois</a>
      <ul>
        <li><a href="#horaire">Horaire</a></li>
      </ul>
    </li>
    <li><a href="#exécuter-maintenant">Exécuter maintenant</a>
      <ul>
        <li><a href="#changements-prévus">Changements prévus</a></li>
        <li><a href="#comportement-en-lecture-seule-des-flux-planifiés">Comportement en lecture seule des flux planifiés</a></li>
      </ul>
    </li>
    <li><a href="#messages-derreur">Messages d’erreur</a>
      <ul>
        <li><a href="#message-derreur---invalidargument---impossible-de-trouver-une-connexion-valide-associée-à-la-référence-de-connexion-fournie-">Message d’erreur : « InvalidArgument - Impossible de trouver une connexion valide associée à la référence de connexion fournie. »</a></li>
      </ul>
    </li>
    <li><a href="#notes">Notes</a></li>
    <li><a href="#installer">Installer</a></li>
    <li><a href="#feuille-de-route">Feuille de route</a></li>
    <li><a href="#rétroaction">Rétroaction</a></li>
  </ul>
</nav>
<h2 id="introduction">Introduction</h2>
<p>Le Planificateur du Kit d’automatisation permet d’afficher la planification des flux Power Automate Cloud récurrents dans les solutions qui incluent des appels aux flux Power Automate Desktop.</p>
<p>Cette fonctionnalité a été mise à jour dans le cadre de l&rsquo; <a href="https://microsoft.github.io/powercat-automation-kit/fr/releases/march-2023">Mars 2023</a>, les versions ultérieures continueront d’améliorer et de développer les fonctionnalités du planificateur.</p>
<style>
    .outerBorder {
        border: 1px;
        color: black;
        border-style: solid;
        margin-bottom: 10px;
    }

    .outerBorder > center {
        padding: 5px;
    }
</style>
<div class="outerBorder">
    <center>

    <img src="https://microsoft.github.io/powercat-automation-kit/images/schedule.png" alt="Programmateur">

    </center>
</div>

<p>Les principales caractéristiques du planificateur sont les suivantes :</p>
<ul>
<li>La possibilité de visualiser la planification des flux cloud récurrents</li>
<li>Filtrer la planification par machine et groupes de machines</li>
<li>Exécuter un flux Power Automate Desktop</li>
<li>Voir le calendrier par jour, semaine, mois et affichage horaire</li>
<li>Afficher l’état des flux planifiés (Succès, Échec ou Planifié)</li>
<li>Afficher la durée d’une exécution de Cloud Flow</li>
<li>Affichez les détails des erreurs.</li>
</ul>
<h2 id="flux-de-nuages">Flux de nuages</h2>
<p>Comme indiqué ci-dessus, seuls les flux de nuages inclus dans une solution. Le récent <a href="https://powerautomate.microsoft.com/vi-vn/blog/more-manageable-cloud-flows-with-dataverse-solutions-by-default/">https://powerautomate.microsoft.com/blog/more-manageable-cloud-flows-with-dataverse-solutions-by-default/</a> inclut des informations sur l’utilisation de la nouvelle version préliminaire des « solutions Dataverse par défaut » pour garantir que les flux cloud sont inclus dans les solutions. L’utilisation de cette fonctionnalité peut aider les utilisateurs à s’assurer que les flux cloud planifiés créés sont visibles dans le planificateur.</p>
<h2 id="affichages-du-calendrier">Affichages du calendrier</h2>
<h2 id="vues-jour-semaine-mois">Vues jour, semaine, mois</h2>
<p>Les vues jour, semaine, mois affichent des informations sur les exécutions de flux Desktop Cloud qui ont été exécutées ou planifiées.</p>
<p>Les articles sont codés par couleur comme suit :</p>
<ul>
<li>
<p>Le vert indique une exécution réussie</p>
</li>
<li>
<p>Le rouge indique l’échec de l’exécution</p>
</li>
<li>
<p>Le bleu indique une exécution future planifiée.</p>
</li>
</ul>
<p>Les informations d’état et d’exécution sont disponibles avec une longue souris tactile ou survolée sur l’événement.</p>
<h3 id="horaire">Horaire</h3>
<style>
    .outerBorder {
        border: 1px;
        color: black;
        border-style: solid;
        margin-bottom: 10px;
    }

    .outerBorder > center {
        padding: 5px;
    }
</style>
<div class="outerBorder">
    <center>

    <img src="https://microsoft.github.io/powercat-automation-kit/images/scheduler-schedule-view.png" alt="Planificateur - Exécuter maintenant">

    </center>
</div>

<p>La vue de planification inclut un ensemble de flux de nuages basés sur l’heure actuelle et les flux planifiés futurs au cours des prochains jours.</p>
<h2 id="exécuter-maintenant">Exécuter maintenant</h2>
<style>
    .outerBorder {
        border: 1px;
        color: black;
        border-style: solid;
        margin-bottom: 10px;
    }

    .outerBorder > center {
        padding: 5px;
    }
</style>
<div class="outerBorder">
    <center>

    <img src="https://microsoft.github.io/powercat-automation-kit/images/scheduler-run-now.png" alt="Planificateur - Exécuter maintenant">

    </center>
</div>

<p>La version actuelle de l’Exécuter maintenant exécute le bureau Power Automate. Il est supposé qu’aucun paramètre n’est requis pour exécuter le flux de bureau. Les informations d’exécution supplémentaires sont disponibles dans les informations de dernière exécution du bureau.</p>
<h3 id="changements-prévus">Changements prévus</h3>
<p>Dans les versions futures, les éléments suivants sont considérés comme de nouvelles fonctionnalités :</p>
<ol>
<li>
<p>Exécutez le flux cloud plutôt que le flux de bureau. Cela inclura ensuite l’historique d’exécution du flux cloud et l’exécution de toutes les actions et paramètres de flux cloud supplémentaires transmis au flux de bureau.</p>
</li>
<li>
<p>Ouvrez les pages d’exécution Desktop et Cloud Flow.</p>
</li>
</ol>
<h3 id="comportement-en-lecture-seule-des-flux-planifiés">Comportement en lecture seule des flux planifiés</h3>
<p>Par défaut, lorsqu’un flux est planifié pour une exécution future, il est défini en mode lecture seule et désactivé pour une exécution immédiate. Cela signifie que les utilisateurs ne peuvent pas modifier ou exécuter le flux tant que la date et l’heure planifiées ne sont pas écoulées. Ce comportement est conçu pour fournir une meilleure expérience utilisateur et empêcher l’exécution accidentelle des flux avant qu’ils ne soient destinés à s’exécuter.
Cette approche présente plusieurs avantages, notamment :</p>
<ul>
<li>
<p>Prévention de l’exécution accidentelle : en désactivant l’exécution immédiate des flux planifiés pour une exécution ultérieure, les utilisateurs sont moins susceptibles d’exécuter accidentellement un flux avant qu’il ne soit destiné à s’exécuter.</p>
</li>
<li>
<p>Amélioration de la prévisibilité : en définissant les flux en mode lecture seule lorsqu’ils sont planifiés pour une exécution future, les utilisateurs peuvent plus facilement prédire quand les flux s’exécuteront et s’assurer qu’ils disposent des entrées et des ressources nécessaires.</p>
</li>
<li>
<p>Expérience utilisateur cohérente : en standardisant le comportement des flux planifiés, il peut fournir une expérience utilisateur cohérente et prévisible sur toutes les instances de Flow.</p>
</li>
<li>
<p>Pour modifier ou exécuter un flux planifié, les utilisateurs peuvent modifier le flux et mettre à jour la date et l’heure planifiées. Une fois la nouvelle planification définie, le flux sera à nouveau désactivé pour une exécution immédiate et défini en mode lecture seule jusqu’à ce que la nouvelle planification soit passée.</p>
</li>
</ul>
<h2 id="messages-derreur">Messages d’erreur</h2>
<p>Messages d’erreur possibles pouvant se produire lors de l’exécution du flux d’exécution.</p>
<h3 id="message-derreur---invalidargument---impossible-de-trouver-une-connexion-valide-associée-à-la-référence-de-connexion-fournie-">Message d’erreur : « InvalidArgument - Impossible de trouver une connexion valide associée à la référence de connexion fournie. »</h3>
<h4 id="description">Description</h4>
<p>Ce message d’erreur indique généralement qu’il existe un problème avec la référence de connexion fournie dans le code ou la configuration. Le système ne peut pas localiser une connexion valide associée à la référence, ce qui l’empêche d’exécuter l’action demandée.</p>
<h4 id="causes">Causes</h4>
<p>Il existe plusieurs causes potentielles de ce message d’erreur, notamment :</p>
<ul>
<li>
<p>Référence de connexion incorrecte ou non valide : la référence de connexion fournie peut être non valide ou incorrecte, ce qui peut empêcher le système de localiser une connexion valide qui lui est associée.</p>
</li>
<li>
<p>Connexion supprimée ou modifiée : si la connexion utilisée dans le code ou la configuration a été supprimée ou modifiée, le système peut ne pas localiser une connexion valide associée à la référence.</p>
</li>
<li>
<p>Problème d’autorisations : le compte d’utilisateur exécutant le code ou la configuration peut ne pas disposer des autorisations nécessaires pour accéder à la connexion ou aux ressources qui lui sont associées.</p>
</li>
</ul>
<h4 id="résolution">Résolution</h4>
<p>Pour résoudre ce problème, vous pouvez suivre les étapes suivantes :</p>
<ul>
<li>
<p>Vérifier la référence de connexion : vérifiez la référence de connexion fournie dans le code ou la configuration et assurez-vous qu’elle est valide et correcte.</p>
</li>
<li>
<p>Supprimer les connexions existantes et recréer : si le vérificateur de flux avertit qu’une référence de connexion n’a pas été utilisée, vous pouvez utiliser le vérificateur de flux pour supprimer les connexions existantes. Une fois les connexions supprimées, vous pouvez recréer des références de connexion au groupe Machine ou Machine pour permettre l’exécution du flux.</p>
</li>
</ul>
<h2 id="notes">Notes</h2>
<p>Pour la version actuelle, les remarques suivantes s’appliquent</p>
<ol>
<li>Seules les solutions Power Automate Desktop et Power Automate contenues dans une solution sont affichées</li>
<li>Au moins un Power Automate Desktop a été enregistré et exécuté</li>
</ol>
<h2 id="installer">Installer</h2>
<p>Pour installer la solution de planificateur, vous pouvez effectuer les opérations suivantes :</p>
<ol>
<li>Vérifier que l’infrastructure des composants Power Apps est activée <a href="https://learn.microsoft.com/power-apps/developer/component-framework/component-framework-for-canvas-apps#enable-the-power-apps-component-framework-feature" target="_blank">Lire la suite</a></li>
<li>Vous avez installé le Creator Kit dans l’environnement cible. <a href="https://appsource.microsoft.com/product/dynamics-365/microsoftpowercatarch.creatorkit1" target="_blank">Installer à partir de la source de l’application</a></li>
<li>Vous avez téléchargé le fichier AutomationKit.zip à partir de la section Actifs de la dernière version <a href="https://github.com/microsoft/powercat-automation-kit/releases" target="_blank">Version de GitHub</a></li>
<li>Vous avez importé la dernière version d’AutomationKitScheduler_*_géré.zip fichier à l’aide. <a href='https://learn.microsoft.com/power-apps/maker/data-platform/import-update-export-solutions' target="_blank">Lire la suite</a></li>
</ol>
<h2 id="feuille-de-route">Feuille de route</h2>
<p>Vous pouvez visiter notre <a href="https://github.com/microsoft/powercat-automation-kit/issues?q=is%3Aissue+is%3Aopen+label%3Ascheduler" target="_blank">Problèmes GitHub</a> pour afficher les nouvelles fonctionnalités proposées.</p>
<p>Vous pouvez ajouter un nouveau <a href="https://github.com/microsoft/powercat-automation-kit/issues/new?assignees=&labels=automation-kit%2Cenhancement%2Cscheduler&template=2-automation-kit-feature.yml&title=%5BAutomation+Kit+-+Feature%5D%3A+FEATURE+TITLE" target="_blank">Demande de fonctionnalité du planificateur</a></p>
<h2 id="rétroaction">Rétroaction</h2>













<script>
    
    
    data = "{\r\n  \"triggers\": [\r\n    {\r\n      \"type\": \"setvalue\",\r\n      \"expression\": \"{send-results} = true\",\r\n      \"setToName\": \"code\",\r\n      \"setValue\": \"Feedback-AK4PP-Scheduler\"\r\n    }\r\n  ],\r\n  \"pages\": [\r\n    {\r\n      \"name\": \"welcome\",\r\n      \"elements\": [\r\n        {\r\n          \"type\": \"checkbox\",\r\n          \"name\": \"features\",\r\n          \"title\": {\r\n            \"default\": \"Which of the following is most useful for your related to Scheduler functionality?\",\r\n            \"fr\": \"Lequel des éléments suivants est le plus utile pour votre fonctionnalité liée au planificateur ?\"\r\n          },\r\n          \"isRequired\": true,\r\n          \"colCount\": 1,\r\n          \"hasOther\": true,\r\n          \"choices\": [\r\n            {\r\n              \"value\": \"The ability to view schedules by day\",\r\n              \"text\": {\r\n                \"default\": \"The ability to view schedules by day\",\r\n                \"fr\": \"La possibilité de visualiser les horaires par jour\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"The ability to view schedules by week\",\r\n              \"text\": {\r\n                \"default\": \"The ability to view schedules by week\",\r\n                \"fr\": \"La possibilité de consulter les horaires par semaine\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"The ability to view schedules by month\",\r\n              \"text\": {\r\n                \"default\": \"The ability to view schedules by month\",\r\n                \"fr\": \"La possibilité d’afficher les plannings par mois\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"The ability to run a flow\",\r\n              \"text\": {\r\n                \"default\": \"The ability to run a flow\",\r\n                \"fr\": \"La possibilité d’exécuter un flux\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"See the results of runs\",\r\n              \"text\": {\r\n                \"default\": \"See the results of runs\",\r\n                \"fr\": \"Voir les résultats des courses\"\r\n              }\r\n            }\r\n          ]\r\n        },\r\n        {\r\n          \"type\": \"checkbox\",\r\n          \"name\": \"new-features\",\r\n          \"title\": {\r\n            \"default\": \"What new features would you like added to the Scheduler functionality?\",\r\n            \"fr\": \"Quelles nouvelles fonctionnalités souhaitez-vous ajouter à la fonctionnalité Planificateur ?\"\r\n          },\r\n          \"isRequired\": true,\r\n          \"colCount\": 1,\r\n          \"hasOther\": true,\r\n          \"choices\": [\r\n            {\r\n              \"value\": \"The ability to filter by status (Success, Fail, Scheduled)\",\r\n              \"text\": {\r\n                \"default\": \"The ability to filter by status (Success, Fail, Scheduled)\",\r\n                \"fr\": \"La possibilité de filtrer par statut (Succès, Échec, Planifié)\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"The ability to filter by machine / machine group\",\r\n              \"text\": {\r\n                \"default\": \"The ability to filter by machine / machine group\",\r\n                \"fr\": \"La possibilité de filtrer par machine / groupe de machines\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"Define alerts for failed runs\",\r\n              \"text\": {\r\n                \"default\": \"Define alerts for failed runs\",\r\n                \"fr\": \"Définir des alertes pour les exécutions ayant échoué\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"Restart / Stop flow execution\",\r\n              \"text\": {\r\n                \"default\": \"Restart / Stop flow execution\",\r\n                \"fr\": \"Redémarrer / Arrêter l’exécution du flux\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"Define dependencies between flow runs\",\r\n              \"text\": {\r\n                \"default\": \"Define dependencies between flow runs\",\r\n                \"fr\": \"Définir les dépendances entre les exécutions de flux\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"See the results of runs\",\r\n              \"text\": {\r\n                \"default\": \"See the results of runs\",\r\n                \"fr\": \"Voir les résultats des courses\"\r\n              }\r\n            }\r\n          ]\r\n        },\r\n        {\r\n          \"type\": \"boolean\",\r\n          \"name\": \"send-results\",\r\n          \"label\": {\r\n            \"default\": \"Do you want to send the feedback on Scheduler?\",\r\n            \"fr\": \"Voulez-vous envoyer vos commentaires sur Planificateur ?\"\r\n          },\r\n          \"isRequired\": true\r\n        },\r\n        {\r\n          \"type\": \"html\",\r\n          \"visibleIf\": \"{send-results} = true\",\r\n          \"html\": {\r\n            \"default\": \"We look forward to getting your feedback. As a core Automation Kit team we use the feedback to improving our guidance and roadmap\",\r\n            \"fr\": \"Nous sommes impatients de recevoir vos commentaires. En tant qu’équipe de base du kit d’automatisation, nous utilisons les commentaires pour améliorer nos conseils et notre feuille de route\"\r\n          }\r\n        },\r\n        {\r\n          \"type\": \"text\",\r\n          \"name\": \"optional-name\",\r\n          \"title\": {\r\n            \"default\": \"You name (optional)\",\r\n            \"fr\": \"Votre nom (facultatif)\"\r\n          },\r\n          \"visibleIf\": \"{send-results} = true\"\r\n        },\r\n        {\r\n          \"type\": \"text\",\r\n          \"name\": \"optional-name\",\r\n          \"title\": {\r\n            \"default\": \"You name (optional)\",\r\n            \"fr\": \"Votre nom (facultatif)\"\r\n          },\r\n          \"visibleIf\": \"{send-results} = true\"\r\n        },\r\n        {\r\n          \"type\": \"text\",\r\n          \"name\": \"optional-organization\",\r\n          \"title\": {\r\n            \"default\": \"You organization (optional)\",\r\n            \"fr\": \"Votre organisation (facultatif)\"\r\n          },\r\n          \"visibleIf\": \"{send-results} = true\"\r\n        },\r\n        {\r\n          \"type\": \"dropdown\",\r\n          \"name\": \"optional-role\",\r\n          \"title\": {\r\n            \"default\": \"Role (optional)\",\r\n            \"fr\": \"Rôle (facultatif)\"\r\n          },\r\n          \"choices\": [\r\n            {\r\n              \"value\": \"COE Administrator\",\r\n              \"text\": {\r\n                \"default\": \"COE Administrator\",\r\n                \"fr\": \"Administrateur du CE\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"Automation Engineer\",\r\n              \"text\": {\r\n                \"default\": \"Automation Engineer\",\r\n                \"fr\": \"Ingénieur en automatisation\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"Business User\",\r\n              \"text\": {\r\n                \"default\": \"Business User\",\r\n                \"fr\": \"Utilisateur professionnel\"\r\n              }\r\n            },\r\n            {\r\n              \"value\": \"Other\",\r\n              \"text\": {\r\n                \"default\": \"Other\",\r\n                \"fr\": \"Autre\"\r\n              }\r\n            }\r\n          ]\r\n        },\r\n        {\r\n          \"type\": \"text\",\r\n          \"name\": \"optional-role-other\",\r\n          \"title\": {\r\n            \"default\": \"You role\",\r\n            \"fr\": \"Votre rôle\"\r\n          },\r\n          \"visibleIf\": \"{optional-role} = 'Other'\"\r\n        },\r\n        {\r\n          \"type\": \"text\",\r\n          \"name\": \"optional-contact\",\r\n          \"title\": {\r\n            \"default\": \"You contact details (optional)\",\r\n            \"fr\": \"Vos coordonnées (facultatif)\"\r\n          },\r\n          \"visibleIf\": \"{send-results} = true\"\r\n        },\r\n        {\r\n          \"type\": \"comment\",\r\n          \"name\": \"other-feedback\",\r\n          \"title\": {\r\n            \"default\": \"Did you have any other feedback?\",\r\n            \"fr\": \"Avez-vous eu d’autres retours ?\"\r\n          },\r\n          \"visibleIf\": \"{send-results} = true\"\r\n        },\r\n        {\r\n          \"type\": \"feedback-task\",\r\n          \"name\": \"send-results\",\r\n          \"title\": {\r\n            \"default\": \"Send your feedback now?\",\r\n            \"fr\": \"Envoyer vos commentaires maintenant?\"\r\n          },\r\n          \"destination\": \"https://aka.ms/ak4pp-feedback2\",\r\n          \"visibleIf\": \"{send-results} = true\"\r\n        },\r\n        {\r\n          \"type\": \"html\",\r\n          \"visibleIf\": \"{send-results-status.length} \u003e 0\",\r\n          \"html\": {\r\n            \"default\": \"Status: {send-results-status}\",\r\n            \"fr\": \"Statut: \"\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}"
    
</script>

<style>
    #questions {
        margin-bottom: 20px;
    }
    .sv-btn {
        border-radius: 0.3em;
    }
</style>

<div id="questions">
</div>

<noscript>
    <p>JavaScript doit être activé pour afficher ce contenu</p>
</noscript>



<script>
    class QuestionExtensions {
        constructor() {
            this.feedbackTask();
            this.importTask();
            this.imageTask();
            this.downloadTask();
            this.handoffTask();
            this.createConnection();
            this.markdown();
        }

        markdown() {
            var widget = {
                name: "markdown",
                title: "Markdown",
                iconName: "",
                widgetIsLoaded: function () {
                    return true;
                },
                defaultJSON: {

                },
                isFit: function (question) {
                    return question.getType() === "markdown";
                },
                isDefaultRender: false,
                htmlTemplate: "<div id='markdownContent'></div>",
                activatedByChanged: function (activatedBy) {
                    Survey.JsonObject.metaData.addClass(
                        "markdown", [
                        {
                            name: "name",
                            type: "text",
                            default: ""
                        },
                        {
                            name: "title",
                            type: "text",
                            default: ""
                        },
                        {
                            name: "markdown",
                            type: "text",
                            default: ""
                        }
                    ], null, "empty");
                },
                afterRender: function (question, el) {
                    question.valueChangedCallback = initWidget;
                    question.readOnlyChangedCallback = initWidget;

                    if (!question.survey[question.name + '_loaded']) {
                        initWidget();
                    }

                    function initWidget() {
                        question.survey.setValue(question.name + '_loaded', true)
                        $("#markdownContent").attr('id', question.name)
                        const converter = new showdown.Converter();
                        $("#" + question.name).html(converter.makeHtml(question.markdown));
                    };
                },
                willUnmount: function (question, el) {
                    el.innerHTML = null;
                    question.readOnlyChangedCallback = null;
                }
            };
            Survey.CustomWidgetCollection.Instance.addCustomWidget(widget, "customtype");
        }

        createConnection() {
            var widget = {
                name: "create-connection",
                title: "Create Connection",
                iconName: "",
                widgetIsLoaded: function () {
                    return true;
                },
                defaultJSON: {

                },
                isFit: function (question) {
                    return question.getType() === "create-connection";
                },
                isDefaultRender: false,
                htmlTemplate: "<div><fluent-button appearance='accent' id='createConnection'></fluent-button></div>",
                activatedByChanged: function (activatedBy) {
                    Survey.JsonObject.metaData.addClass(
                        "create-connection", [
                        {
                            name: "name",
                            type: "text",
                            default: ""
                        },
                        {
                            name: "title",
                            type: "text",
                            default: ""
                        },
                        {
                            name: "connector",
                            type: "text",
                            default: ""
                        },
                        {
                            name: "environment",
                            type: "text",
                            default: ""
                        }
                    ], null, "empty");
                },
                afterRender: function (question, el) {
                    question.valueChangedCallback = initWidget;
                    question.readOnlyChangedCallback = initWidget;

                    if (!question.survey[question.name + '_loaded']) {
                        initWidget();
                    }

                    function initWidget() {
                        question.survey.setValue(question.name + '_loaded', true)
                        $("#createConnection").attr('id', question.name)
                        $("#" + question.name).closest(".sv-question").parent().attr("style","")
                        $("#" + question.name).html(question.title);
                        $("#" + question.name).on("click", function() {
                            let environment = question.survey.data[question.environment]
                            if ( typeof environment !== "undefined" && environment.length > 0 ) {
                                environment = environment.replaceAll("/home", "/connections/available?apiName=" + question.connector)
                                window.open(environment)
                            }
                        });
                    };
                },
                willUnmount: function (question, el) {
                    el.innerHTML = null;
                    question.readOnlyChangedCallback = null;
                }
            };

            
            Survey.CustomWidgetCollection.Instance.addCustomWidget(widget, "customtype");
        }

        downloadTask() {
            var widget = {
                name: "download-task",
                title: "Download Task",
                iconName: "",
                widgetIsLoaded: function () {
                    return true;
                },
                defaultJSON: {

                },
                isFit: function (question) {
                    return question.getType() === "download-task";
                },
                isDefaultRender: false,
                htmlTemplate: "<div><fluent-button appearance='accent' id='downloadLink'>Télécharger</fluent-button><a id='downloadData' style='display:none'></a></div>",
               activatedByChanged: function (activatedBy) {
                    Survey.JsonObject.metaData.addClass(
                        "download-task", [
                        {
                            name: "name",
                            type: "text",
                            default: ""
                        },
                        {
                            name: "filter",
                            type: "text",
                            default: ""
                        },
                        {
                            name: "text",
                            type: "text",
                            default: ""
                        },
                        {
                            name: "fileName",
                            type: "text",
                            default: "results.json"
                        }
                    ], null, "empty");
                },
                afterRender: function (question, el) {
                    question.valueChangedCallback = initWidget;
                    question.readOnlyChangedCallback = initWidget;

                    if (!question.survey[question.name + '_loaded']) {
                        initWidget();
                    }

                    function initWidget() {
                        question.survey.setValue(question.name + '_loaded', true)
                        $("#downloadLink").html(question.text);
                        $("#downloadLink").on("click", function() {
                            var data = question.survey.data;
                            if ( question.filter.length > 0 ) {
                                var newData = {}
                                for (const key in data) {
                                    if (data.hasOwnProperty(key) && key.startsWith(question.filter + "-")) {
                                        newData[key] = data[key]
                                    }
                                }
                                data = newData;
                            }
                            var jsonString = JSON.stringify(data);
                            var blob = new Blob([jsonString], { type: 'application/json' });
                            var anchor = document.getElementById('downloadData');
                            anchor.download = question.fileName;
                            anchor.href = window.URL.createObjectURL(blob);
                            anchor.dataset.downloadUrl = [ 'application/json', anchor.download, anchor.href].join(':');
                            anchor.click()
                        });
                    };
                },
                willUnmount: function (question, el) {
                    el.innerHTML = null;
                    question.readOnlyChangedCallback = null;
                }
            };
            Survey.CustomWidgetCollection.Instance.addCustomWidget(widget, "customtype");
        }

        handoffTask() {
            var widget = {
                name: "handoff-task",
                title: "Handoff Task",
                iconName: "",
                widgetIsLoaded: function () {
                    return true;
                },
                defaultJSON: {

                },
                isFit: function (question) {
                    return question.getType() === "handoff-task";
                },
                isDefaultRender: false,
                htmlTemplate: "<div><a class='button cta rounded primary-btn raised' id='handoff'></a>",
                activatedByChanged: function (activatedBy) {
                    Survey.JsonObject.metaData.addClass(
                        "handoff-task", [
                        {
                            name: "destination",
                            type: "text",
                            default: ""
                        },
                        {
                            name: "text",
                            type: "text",
                            default: ""
                        }
                    ], null, "empty");
                },
                afterRender: function (question, el) {
                    question.valueChangedCallback = initWidget;
                    question.readOnlyChangedCallback = initWidget;

                    if (!question.survey[question.name + '_loaded']) {
                        initWidget();
                    }

                    function initWidget() {
                        question.survey.setValue(question.name + '_loaded', true)
                        $("#handoff").html(question.text);
                        $("#handoff").on("click", function() {
                            const parameterRegularExpression = new RegExp("\{([^}]+)\}","g")
                            var matches = question.destination.match(parameterRegularExpression)
                            var destination = question.destination
                            for ( var i = 0; i < matches.length; i++) {
                                let name = matches[i].replaceAll("{","").replaceAll("}","")
                                destination = destination.replaceAll(matches[i], question.survey.data[name])
                            }
                            window.location = destination;
                        })  
                    };
                },
                willUnmount: function (question, el) {
                    el.innerHTML = null;
                    question.readOnlyChangedCallback = null;
                }
            };
            Survey.CustomWidgetCollection.Instance.addCustomWidget(widget, "customtype");
        }

        feedbackTask() {
            var widget = {
                name: "feedback-task",
                title: "Feedback Task",
                iconName: "",
                widgetIsLoaded: function () {
                    return true;
                },
                defaultJSON: {

                },
                isFit: function (question) {
                    return question.getType() === "feedback-task";
                },
                isDefaultRender: false,
                htmlTemplate: "<div><fluent-button appearance='accent' id='sendFeedback'>Répondez aux questions et envoyez des commentaires</fluent-button>",
                activatedByChanged: function (activatedBy) {
                    Survey.JsonObject.metaData.addClass(
                        "feedback-task", [
                        {
                            name: "destination",
                            type: "text",
                            default: ""
                        }
                    ], null, "empty");
                },
                afterRender: function (question, el) {
                    question.valueChangedCallback = initWidget;
                    question.readOnlyChangedCallback = initWidget;

                    if (!question.survey[question.name + '_loaded']) {
                        initWidget();
                    }

                    function initWidget() {
                        $("#sendFeedback").on("click", function() {
                            if ( question.survey.completeLastPage() ) {
                                question.survey.setValue(question.name + "-status", 'Envoi de commentaires')

                                $.ajax({
                                        type: "GET",
                                        url: question.destination,
                                        success: function (response) {
                                            $.ajax
                                            ({
                                                type: "POST",
                                                url: response.url,
                                                dataType: 'json',
                                                async: false,
                                                cors: true,
                                                data: JSON.stringify(question.survey.data),
                                                success: function (result) {
                                                    question.survey.setValue(question.name + "-status", result.status)
                                                },
                                                error: function() {
                                                    question.survey.setValue(question.name + "-status", 'Impossible d’envoyer des commentaires')
                                                }
                                            });
                                            }
                                    });
                            } else {
                                question.survey.setValue(question.name + "-status", 'Valider que les questions sont complètes')
                            }
                        })  
                    };
                },
                willUnmount: function (question, el) {
                    el.innerHTML = null;
                    question.readOnlyChangedCallback = null;
                }
            };
            Survey.CustomWidgetCollection.Instance.addCustomWidget(widget, "customtype");
        }

        importTask() {
            var widget = {
                name: "importTask",
                title: "Import Task",
                iconName: "",
                widgetIsLoaded: function () {
                    return true;
                },
                defaultJSON: {

                },
                isFit: function (question) {
                    return question.getType() === "import-task";
                },
                isDefaultRender: false,
                htmlTemplate: "<div></div>",
                activatedByChanged: function (activatedBy) {
                    Survey.JsonObject.metaData.addClass(
                        "import-task", [
                        {
                            name: "src",
                            type: "text",
                            default: ""
                        },
                        {
                            name: "mode",
                            type: "text",
                            default: ""
                        }
                    ], null, "empty");
                },
                afterRender: function (question, el) {
                    question.valueChangedCallback = initWidget;
                    question.readOnlyChangedCallback = initWidget;

                    if (!question.survey[question.name + '_loaded']) {
                        initWidget();
                    }

                    function initWidget() {
                        console.log('Loading')
                        fetch(question.src)
                            .then(function (response) {
                                if (response.ok) {
                                    return response.text();
                                }
                                throw new Error('La réponse du réseau n’était pas correcte.');
                            })
                            .then(function (jsonContent) {
                                question.survey[question.name + '_loaded'] = true;
                                var importSurvey = new Model(jsonContent);
                                if (question.hasOwnProperty('mode')) {
                                    switch (question.mode) {
                                        case 'merge':
                                            for (var i = 0; i < importSurvey.pages.length; i++) {
                                                for (var q = 0; q < question.survey.pages.length; q++) {
                                                    if (question.survey.pages[q].name === importSurvey.pages[i].name) {
                                                        for (var e = 0; e < importSurvey.pages[i].elements.length; e++) {
                                                            question.survey.pages[q].elements.push(importSurvey.pages[i].elements[e])
                                                        }
                                                    }
                                                }
                                            }
                                            break;
                                        case 'insert':
                                        case 'replace':
                                            var selectedPage = question.survey.currentPageNo;
                                            var newPages = [];
                                            
                                            for (var i = 0; i < importSurvey.pages.length; i++) {
                                                var newPage = question.survey.addNewPage(importSurvey.pages[i].name);
                                                newPages.push(newPages)
                                                for (var e = 0; e < importSurvey.pages[i].elements.length; e++) {
                                                    newPage.elements.push(importSurvey.pages[i].elements[e])
                                                }
                                                newPage.title = importSurvey.pages[i].title;
                                                newPage.visibleIf = importSurvey.pages[i].visibleIf;
                                                
                                                question.survey.pages.splice(selectedPage + i + 1, 0, question.survey.pages.splice(question.survey.pages.length - 1, 1)[0]);
                                                question.survey.runConditions();
                                                question.survey.updateVisibleIndexes();
                                            }
                                            if (question.mode == 'replace') {
                                                question.survey.removePage(question.survey.pages[selectedPage]);
                                            }
                                            question.survey.currentPageNo = selectedPage;
                                            break;
                                        default:
                                            for (var i = 0; i < importSurvey.pages.length; i++) {
                                                var newPage = question.survey.addNewPage(importSurvey.pages[i].name);
                                                for (var e = 0; e < importSurvey.pages[i].elements.length; e++) {
                                                    newPage.elements.push(importSurvey.pages[i].elements[e])
                                                }
                                                newPage.title = importSurvey.pages[i].title;
                                                newPage.visibleIf = importSurvey.pages[i].visibleIf;
                                            }
                                    }
                                }
                            })
                    };
                },
                willUnmount: function (question, el) {
                    el.innerHTML = null;
                    question.readOnlyChangedCallback = null;
                }
            };

            Survey.CustomWidgetCollection.Instance.addCustomWidget(widget, "customtype");
        }

        imageTask() {
            var self = this;
            var widget = {
                name: "imageTask",
                title: "Image Task",
                iconName: "",
                widgetIsLoaded: function () {
                    return true;
                },
                defaultJSON: {

                },
                isFit: function (question) {
                    return question.getType() === "image-task";
                },
                isDefaultRender: false,
                htmlTemplate: "<div></div>",
                activatedByChanged: function (activatedBy) {
                    Survey.JsonObject.metaData.addClass(
                        "image-task", [
                        {
                            name: "src",
                            type: "text",
                            default: ""
                        }
                    ], null, "empty");
                },
                afterRender: function (question, el) {
                    if (!question.survey[question.name + '_loaded']) {
                        initWidget();
                    }

                    question.valueChangedCallback = initWidget;
                    question.readOnlyChangedCallback = initWidget;

                    function initWidget() {
                        if (question.survey[question.name + '_loaded']) {
                            return;
                        }

                        fetch(question.src)
                            .then(function (response) {
                                if (response.ok) {
                                    return response.text();
                                }
                                throw new Error('La réponse du réseau n’était pas correcte.');
                            })
                            .then(function (svgContent) {
                                el.innerHTML = svgContent;
                                if (typeof self !== "undefined") {
                                    self.componentSelect(question.survey, question, el);
                                }
                            })
                    }
                },
                willUnmount: function (question, el) {
                    el.innerHTML = null;
                    question.readOnlyChangedCallback = null;
                }
            };

            Survey.CustomWidgetCollection.Instance.addCustomWidget(widget, "customtype");
        }

        componentSelect(survey, question, element) {
        console.log('Component Loaded')
        var itemSelected =  ''
        var groupSelected = ''
        var itemUnselected =  ''
        var groupUnselected = ''

        var requiredQuestions = []
        
        for (const a of element.querySelectorAll("a")) {
            if ( typeof a.href !== "undefined" && a.href.baseVal.startsWith("template://") )  {
                var rect = this.findRect(a);
                if (rect == null) {
                    var rect = this.findPath(a);
                }

                if (rect != null)
                {
                    var classVal = rect.getAttribute("class");
                    switch ( a.href.baseVal ) {
                        case "template://group/selected":
                            groupSelected = classVal;
                            break;
                        case "template://group/unselected":
                            groupUnselected = classVal;
                            break;
                        case "template://item/selected":
                            itemSelected = classVal;
                            break;
                        case "template://item/unselected":
                            itemUnselected = classVal;
                            break;
                    }
                }
            }

            if ( typeof a.href !== "undefined" && a.href.baseVal.startsWith("required://") )  {
                var parts = a.href.baseVal.split('/')
                var requiredQuestionId = parts[parts.length -1]
                if ( requiredQuestions.indexOf(requiredQuestionId) == -1) {
                    requiredQuestions.push(requiredQuestionId)
                }
            }
        }

        this.updateComplete(survey, question, requiredQuestions, element)

        for (const a of element.querySelectorAll("a")) {        
            if ( typeof a.href !== "undefined" ) {
                var handled = false;
                if (a.href.baseVal.startsWith("question://") || a.href.baseVal.startsWith("option://")) {
                    console.log('Found question ' + a.href.baseVal )
                    this.setupQuestion(survey, a.href.baseVal, a, itemSelected)

                    a.addEventListener("click", (event) => {
                        event.preventDefault();
                        var aLink = this.findLink(event.target);
                        if ( aLink !== null) {
                            var rect = this.findRect(aLink);
                            if (rect == null) {
                                var rect = this.findPath(aLink);
                            }

                            var newClass = itemSelected;
                            if (rect.getAttribute("class") == itemSelected) {
                                newClass = itemUnselected
                            }
                            this.selectQuestion(survey, a.href.baseVal, newClass == itemSelected, element, itemUnselected, () => {
                                this.updateComplete(survey, question, requiredQuestions, element)
                            });

                            if (rect != null) {
                                rect.setAttribute("class", newClass)
                            }
                        }
                    })
                    handled = true;
                }

                if (a.href.baseVal.startsWith("navigate://")) {
                    console.log('Found navigation link ' + a.href.baseVal )
                    a.addEventListener("click", (event) => {
                        event.preventDefault();

                        var parts = a.href.baseVal.split('/');
                    
                        survey.currentPageNo = parseInt(parts[parts.length-1]) - 1;
                    });
                    handled = true;
                }

                if (a.href.baseVal.startsWith("popup://")) {
                    console.log('Found popup link ' + a.href.baseVal )
                    
                    
                    handled = true;
                }

                if (!handled) {
                    a.addEventListener("click", (event) => {
                        event.preventDefault();
                    });
                }
            }
        }
    }
    
    unique(arr) {
        var a = arr.concat();
        for(var i=0; i<a.length; ++i) {
            for(var j=i+1; j<a.length; ++j) {
                if(a[i] === a[j])
                    a.splice(j--, 1);
            }
        }

        return a;
    };

    findQuestion(survey, questionId) {
        var questionMatch = null;
        for ( var p = 0; p < survey.pages.length; p++ ) {
            for ( var q = 0; q < survey.pages[p].questions.length; q++ ) 
            {
                if ( survey.pages[p].questions[q].name == questionId )
                {
                    questionMatch = survey.pages[p].questions[q];
                    break;
                }
            }
        }
        return questionMatch;
    }

    updateComplete(survey, question, requiredList, element) {
        var requiredMatch = 0;
        for (const a of element.querySelectorAll("a")) {
            if ( typeof a.href !== "undefined" && a.href.baseVal.startsWith("required://") )  {
                var parts = a.href.baseVal.split('/')
                var requiredQuestionId = parts[parts.length -1]
                var hasValue = false;
                if (
                    typeof survey.data[requiredQuestionId] !== "undefined" && 
                    (typeof survey.data[requiredQuestionId].length === "number" && survey.data[requiredQuestionId].length > 0)
                ) {
                    requiredMatch++;
                    hasValue = true;
                }

                var path = this.findPath(a);
                if (path != null) {
                    if (hasValue) {
                        path.setAttribute('style', 'display:none')
                    } else {
                        path.setAttribute('style', '')
                    }
                }
            }
        }

        if (typeof question.name === "string") {
            if (requiredMatch == requiredList.length) {
                survey.setValue(question.name, 'complete')
            } else {
                survey.clearValue(question.name)
            }
        } 
    }

    setupQuestion(survey, questionId, element, itemSelected) {
        var parts = questionId.split('/');
        var val = parts[parts.length - 1];
        var question = parts[parts.length - 2];
        
        var currentVal = survey.data[question];

        if ( typeof currentVal === "undefined") {
            return;
        }

        var newClass = '';

        if ( questionId.startsWith('option://') ) {
            if ( val === currentVal ) {
                newClass = itemSelected;
            }
        }

        if ( questionId.startsWith('question://') && currentVal.indexOf(val) >= 0 ) {
            newClass = itemSelected;
        }

        if ( newClass.length > 0)
        {
        var rect = this.findRect(element);
        if (rect == null) {
            var rect = this.findPath(element);
        }
        
        rect.setAttribute('class', newClass)
        }
    }

    selectQuestion(survey, questionId, selected, element, itemUnselected, callback) {
        var parts = questionId.split('/');
        var val = parts[parts.length - 1];
        var question = parts[parts.length - 2];
        var group = parts[parts.length - 3];

        if ( questionId.startsWith('option://') ) {
            this.unselectGroup(element, group, question, itemUnselected);
        }

        if ( questionId.startsWith('option://') && !selected ) {
            survey.clearValue(question);
            if (typeof callback === "function") {
                callback()
            }
            return;
        }

        var newVal = val;

        var currentVal = survey.data[question];
        if ( typeof currentVal === "undefined") {
            if ( questionId.startsWith('question://') ) {
                newVal = selected ? [ val ] : [];
            }
        }
        else
        {
            if ( questionId.startsWith('question://') ) {
                newVal = selected ? [ val ] : [];
                newVal = this.unique(currentVal.concat(newVal));
                if ( !selected ) {
                    
                    var index = newVal.indexOf(val);
                    if (index > -1) {
                        newVal.splice(index, 1);
                    }
                }
            }
        }

        survey.setValue(question, newVal);

        if (typeof callback === "function") {
            callback()
        }
    }

    unselectGroup(element, group, question, classToApply) {
        var items = this.findOptions(element, group, question);

        items.forEach( item => {
            var rect = this.findRect(item);
            if (rect == null) {
                var rect = this.findPath(item);
            }

            if (rect != null) {
                rect.setAttribute('class', classToApply)
            }
        });
    }

    findOptions(element, group, question) {
        var options = []
        this.findChildLink(element, 'option://' + group + "/" + question, options)
        return options;
    }

    findLink(element, startsWith) {
        if (typeof element !== "undefined") {
            if ( typeof element.href !== "undefined" ) {
                if ( typeof startsWith !== "undefined") {
                    if ( element.href.baseVal.startsWith(startsWith) ) {
                        return element;
                    }

                    if ( typeof element.parentElement !== "undefined" ) {
                        return this.findLink(element.parentElement, startsWith)
                    }
                } else {
                    return element
                }
            }

            if ( typeof element.parentElement !== "undefined" ) {
                return this.findLink(element.parentElement, startsWith)
            }
        }
    
        return null;
    }

    findChildLink(element, startsWith, matches) {
        if ( typeof element === "undefined" ) {
            return null;
        }

        if ( typeof element.href !== "undefined" && typeof element.href.baseVal !== "undefined") {
            if ( element.href.baseVal.startsWith(startsWith) ) {
                if ( startsWith !== "undefined" && element.href.baseVal.startsWith(startsWith) ) {
                    matches.push(element);
                }
            }
        }

        if ( typeof element.childNodes !== "undefined" ) {
            for (let child of element.childNodes) {
                if ( typeof startsWith === "string" && typeof child.href !== "undefined" && typeof child.href.baseVal !== "undefined") {
                    if ( child.href.baseVal.startsWith(startsWith) ) {
                        matches.push(child);
                    }
                }
                
                this.findChildLink(child, startsWith, matches);
            }
        }
    }

    findRect(element) {
        for (const rect of element.querySelectorAll("rect")) {
            return rect;
        }
        return null;
    }

    findPath(element) {
        for (const item of element.querySelectorAll("path")) {
            return item;
        }
        return null;
    }
    }

    function contains(params) {
        try {
            if (Array.isArray(params[0]) && Array.isArray(params[1])) {
                for (var i = 0; i < params[1].length; i++) {
                    if (params[0].includes(params[1][i])) {
                        return true
                    }
                }
            }

            if (Array.isArray(params[0]) && !Array.isArray(params[1])) {
                return params[0].includes(params[1]);
            }
        } catch {
            return false
        }
        return false
    }

    function stringLength(params) {
        try {
            return params[0].length
        } catch {
            return false
        }
        return false
    }

    function startsWithFunction(params) {
        try {
            return params[0].startsWith(params[1])
        } catch {
            return false
        }
        return false
    }

    function ceilingFunction(params) {
        try {
            return Math.ceil(params[0])
        } catch {
            return ''
        }
    }

    function parseIntFunction(params) {
        try {
            return parseInt(params[0])
        } catch {
            return ''
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        
        Survey.FunctionFactory
            .Instance
            .register("contains", contains);
        Survey.FunctionFactory
            .Instance
            .register("len", stringLength);
        Survey.FunctionFactory
            .Instance
            .register("startsWith", startsWithFunction);

        Survey.FunctionFactory
            .Instance
            .register("int", parseIntFunction)

        Survey.FunctionFactory
            .Instance
            .register("ceil", ceilingFunction)

        Survey.StylesManager.applyTheme("modern");
        
        

        const converter = new showdown.Converter();
        new QuestionExtensions();

        function loadData(loaded) {
            const questionModel = new Survey.Model(loaded);
            const get_url = window.location.search;
            const url_param = new URLSearchParams(get_url);
            for (let key of url_param.keys()) {
                if ( key == "q" )
                {
                    continue;
                }
                const value = url_param.get(key);
                questionModel.setValue(key, value)
            }
            questionModel.onStarted.add(() => {
                console.log('called')
            })
            questionModel.onProcessHtml.add((survey, options) => {
                if ( typeof options.html == "string" ) {
                    options.html = converter.makeHtml(options.html);
                }
            })
            questionModel.onTextMarkdown.add(function (survey, options) {
                
                let str = converter.makeHtml(options.text);
                if (options.hasOwnProperty('markdown')) {
                    console.log(options.markdown)
                    str = converter.makeHtml(options.markdown);
                }
                
                str = str.substring(3);
                str = str.substring(0, str.length - 4);
                
                options.html = str;
            });
            questionModel.showNavigationButtons = "false"
        
            
            questionModel.locale = "fr"
            
            questionModel.completedHtml = "Merci de nous avoir fait part de vos commentaires";
            questionModel.focusFirstQuestionAutomatic = false;
            
            $("#questions").Survey({ model: questionModel });

            if ( window.surveyChanged != null ) {
                questionModel.onValueChanged.add(window.surveyChanged)
            }
            if ( window.afterRenderQuestion != null ) {
                questionModel.onAfterRenderQuestion.add(window.afterRenderQuestion)
            }

            questionModel.currentPageNo = 0;

            

            return questionModel;
        }

        if ( data != null) {
            const get_url = window.location.search;
            const url_param = new URLSearchParams(get_url);
            const q = url_param.get('q');
            var code = ''
            newData = JSON.parse(data)
            if ( q && q.length > 0 ) {
                try {
                    var questions = JSON.parse(atob(q));
                    code = questions.code;
                    var allowed = ["radiogroup", "checkbox"];
                    if ( Array.isArray(questions.add) ) {
                       for ( var i = questions.add.length - 1; i >= 0; i--) {
                        if ( allowed.indexOf(questions.add[i].type) >= 0) {
                            newData.pages[0].elements = [questions.add[i]].concat(newData.pages[0].elements)
                        }
                       }
                    }
                } catch (ex) {
                    console.log(ex)

                }     
            }
            

            data = JSON.stringify(newData)
            let result = loadData(data)
            if ( code.length > 0 ) {
                result.setValue('code', code)
            }
        }
        else {
            const get_url = window.location.search;
            const url_param = new URLSearchParams(get_url);
            const source = url_param.get('source');
            fetch('/powercat-automation-kit/' + source + ".json")
                .then(async function (response) {
                    if (response.ok) {
                        loadData(await response.text());
                    }
                    throw new Error('La réponse du réseau n’était pas correcte.');
                })
        }
    });
</script>


    </div>
  </div>
</article>

    
    
    <footer class="d-print-none">
    <nav class="navbar navbar-light bg-light d-flex justify-content-around">
  <div class="container pt-3">
    <div class="row d-flex justify-content-center">
      <div class="col-lg-2 col-md-6">
        <div class="footer-logo">
          <img src="https://microsoft.github.io/powercat-automation-kit/images/logos/automation-kit.svg">
        </div>
      </div>
      <div class="col-lg-2 col-md-6">
        <div class="footer-header">
            <h3>Produit</h3>
        </div>
        <ul class="link-list">
          <li>
            <a rel="noopener" target="_blank" href="https://microsoft.github.io/powercat-automation-kit/fr/releases">
              Versions
            </a>
          </li>
          <li>
            <a rel="noopener" target="_blank" href="https://microsoft.github.io/powercat-automation-kit/fr/frequently-asked-questions">
              FAQ
            </a>
          </li>
          <li>
            <a rel="noopener" target="_blank" href="https://microsoft.github.io/powercat-automation-kit/fr/support">
              Soutien
            </a>
          </li>
          <li>
            <a rel="noopener" target="_blank" href="https://microsoft.github.io/powercat-automation-kit/fr/office-hours">
              Heures d’ouverture
            </a>
          </li>
          <li>
            <a rel="noopener" target="_blank" href="https://aka.ms/automation-kit-learn">
              Découvrir les fonctionnalités
            </a>
          </li>
          <li>
            <a rel="noopener" target="_blank" href="https://aka.ms/ak4pp-issues">
              Questions
            </a>
          </li>
          <li>
            <a rel="noopener" target="_blank" href="https://github.com/microsoft/powercat-automation-kit/milestones?status=open">
              Étapes
            </a>
          </li>
          <li>
            <a rel="noopener" target="_blank" href="https://github.com/microsoft/powercat-automation-kit/releases">
              Versions
            </a>
          </li>
          <li>
            <a rel="noopener" target="_blank" href="https://privacy.microsoft.com/privacystatement">
              Politique de confidentialité
            </a>
          </li>
        </ul>
      </div>
      <div class="col-lg-2 col-md-6">
        <div class="footer-header">
            <h3>Apprendre</h3>
        </div>
        <ul class="link-list">
          <li>
            <a rel="noopener" target="_blank" href="https://learn.microsoft.com/power-automate/guidance/automation-kit/setup/prerequisites">
              Démarrer
            </a>
          </li>
          <li>
            <a rel="noopener" target="_blank" href="https://learn.microsoft.com/power-automate/guidance/automation-kit/configure-automation-kit">
              Configurer le kit d’automatisation
            </a>
          </li>
          <li>
            <a rel="noopener" target="_blank" href="https://learn.microsoft.com/power-automate/guidance/automation-kit/use-automation-kit">
              Utiliser le kit d’automatisation
            </a>
          </li>
        </ul>
      </div>
      <div class="col-lg-2 col-md-6">
        <div class="footer-header">
            <h3>Blog</h3>
        </div>
        <ul class="link-list">
          <li>
            <a rel="noopener" target="_blank" href="https://aka.ms/automation-kit-blog">
              Préversion publique
            </a>
          </li>
          <li>
            <a rel="noopener" target="_blank" href="https://powerautomate.microsoft.com/blog/cineplex-digital-transformation-with-power-automate-rpa-led-by-citizen-developers/">
              Témoignage client Cineplex
            </a>
          </li>
        </ul>
      </div>
      <div class="col-lg-2 col-md-6">
        <div class="footer-header">
          <h3></h3>
          <nav class="level is-mobile">
            <div class="level-left">
              <a class="level-item" rel="noopener" target="_blank" href="https://github.com/microsoft/powercat-automation-kit">
                <span class="icon"><i class="fa fa-github"></i></span>
              </a>
            </div>
          </nav>
        </div>
      </div>
    </div>
  </div>

    </nav>
</footer>
    

    

    

    <script src="https://microsoft.github.io/powercat-automation-kit/js/jquery/3.6.1/jquery.min.js" ></script>
<script src="https://microsoft.github.io/powercat-automation-kit/js/feather-icons/4.29.0/feather.min.js" ></script>
<script src="https://microsoft.github.io/powercat-automation-kit/js/modernizr/2.8.3/modernizr.min.js" ></script>
<script src="https://microsoft.github.io/powercat-automation-kit/js/survey-jquery/1.9.55/survey.jquery.min.js" ></script>
<script src="https://microsoft.github.io/powercat-automation-kit/js/showdown/2.1.0/showdown.min.js" ></script>
</html>